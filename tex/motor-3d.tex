\chapter{Programando un motor 3D}
\label{chap:motor-3d}

En este capítulo nos aventuraremos a desarrollar un pequeño motor tridimensional. No construiremos una pieza optimizada de alta tecnología pero aprenderemos algunos de los conceptos que permitieron en el año 1992 a una empresa llamada \emph{ID Software} crear uno de los juegos más emblemáticos de la historia, \textbf{Wolfenstein 3D}.

¿Preparados para poner su cerebro a prueba?

\begin{figure}[h!]
	\centering
	\includegraphics[width=10cm]{./Images/wolf3d.jpg}
	\caption{Wolfenstein uno de los primeros juegos en usar motores 3D de forma efectiva. \emph{La imagen es propiedad de sus respectivos dueños, usada únicamente con fines educativos}.}
	\label{wolf3d}
\end{figure}

\section{Contexto histórico}

\begin{quote}
	\emph{Tenemos esta oportunidad de hacer algo totalmente nuevo aquí, algo rápido y con texturas. Si podemos hacer que los gráficos se vean fantásticos y rápidos, y hacer el sonido fresco y fuerte, y hacer el juego explosivamente divertido, entonces tendremos algo ganador.} \\
	John Romero, en Masters of Doom \cite[p.~92]{doom}.
\end{quote}


\begin{figure}[h!]
	\centering
	\includegraphics[width=10cm]{./Images/keen.png}
	\caption{Keen Commander, anterior a Wolfenstein, también de ID Software, uno de los primeros juegos de plataformas en aprovechar toda la potencia de los ordenadores de la época. \emph{La imagen es propiedad de sus respectivos dueños, usada únicamente con fines educativos}.}
	\label{keen}
\end{figure}

Corría el año de 1992, la mayoría de computadores apenas si tenían capacidad para ejecutar de forma fluida algunos juegos en 2D. \emph{}.

%\begin{figure}[h!]
%	\centering
%	\includegraphics[width=10cm]{./Images/wolf3d-juego.jpg}
%	\caption{Gráficos dentro del juego Wolfenstein 3D. \emph{La imagen es propiedad de sus respectivos dueños, usada únicamente con fines educativos}.}
%	\label{wolf3d-juego}
%\end{figure}

\newpage

\section{Simulando gráficos en 3D}


Dada la poca potencia de los computadores de la época, tener verdaderos gráficos en 3D era una tarea imposible, entonces, ¿cómo hicieron en ID para crear Wolfenstein 3D? La respuesta es que lo que realmente estamos viendo es \emph{una ilusión}.

\begin{figure}[h!]
	\centering
	\includegraphics[width=10cm]{./Images/wolf3d-mapa.png}
	\caption{El mapa siempre fue una cuadrícula bidimensional. El jugador es el punto rojo y el triángulo amarillo refleja el campo de visión.}
	\label{wolf3d-mapa}
\end{figure}

Como se puede apreciar en la figura \ref{wolf3d-mapa}, toda la lógica del juego ocurría en una cuadrícula; la magia era mostrar los laberintos y enemigos cómo si fueran parte de un entorno tridimensional, pero la verdad, nunca dejaron de ser 2D.

Esto traía muchas ventajas a nivel de rendimiento, sin embargo venía con algunas limitaciones, como por ejemplo que al ser realmente un mapa 2D no podían tenerse cuartos unos encima de otros. Aún así, esta estrategia no era suficiente en sí misma, los procesadores de aquella época era muy limitados y para mantener una tasa de refresco lo suficientemente alta, fueron necesarias otras simplificaciones y optimizaciones, entre ellas: que los muros fueran todos en ángulos de $90^{\circ}$, que los mapas siguieran una estricta alineación a una grilla, que el techo y el piso fueran colores planos sin texturas de ningún tipo.

Dicho esto, exploraremos un algoritmo simplificado para realizar el pintado de los escenarios.

\newpage
\subsection{Raycasting}

\begin{wrapfigure}{r}{0.4\textwidth}
	\begin{center}
		\includegraphics[width=0.25\textwidth]{./Images/rays.png}
	\end{center}	
	\caption{Rayos lanzados en el campo de visión del jugador para calcular la distancia de los muros. \newline}
	\label{rays}
	
	\begin{center}
		\includegraphics[width=0.4\textwidth]{./Images/raytracing.png}
	\end{center}	
	\caption{Pintado de los muros de acuerdo a la distancia. Al final se genera la ilusión de un espacio en 3D. \newline}
	\label{raytracing}
	
	\begin{center}
		\includegraphics[width=0.4\textwidth]{./Images/wolf3d-juego.jpg}
	\end{center}
	\caption{Gráficos dentro del Wolfenstein 3D.}
	\label{wolf3d-mapa}

\end{wrapfigure}

El \textbf{Raycasting} es una técnica que consiste en lanzar rayos para determinar cuál es la primer superficie que estos interceptan. El motor de Wolfenstein basaba su renderizado en está técnica. La idea general es la siguiente:

\begin{enumerate}
	\item De acuerdo al campo de visión del jugador empezando desde la izquierda y hasta recorrer todo el cono, se lanzarían unos \emph{rayos} verificando a qué distancia se encuentran los muros. Ver figura \ref{rays}.
	
	\item A continuación, esas distancias se utilizan para pintar en la pantalla, de izquierda a derecha unas líneas verticales representando los muros. Entre mayor sea la distancia, más pequeña debe ser la línea (para dar la sensación de perspectiva). Ver figura \ref{raytracing}.
\end{enumerate}

Con está técnica es posible pintar cualquier mapa de Wolfenstein. Ahora, el algoritmo utilizado por ID tiene muchas optimizaciones y detalles adicionales para conseguir una velocidad de renderizado adecuada, así como permitir detalles que incluyen texturas en los muros, lámparas, objetos, enemigos, entre otros. Sin embargo, para nuestro empeño nos valdremos de esta versión simplificada.

\newpage
\clearpage

\subsection{Código base en PyGame}

\lstinputlisting[language=Python,caption=Código base para el motor.,label=cod-motor-3d-pygame,basicstyle=\fontsize{9}{9}\selectfont\ttfamily]{./py/motor-3d/base-pygame.py}


\newpage 
\subsection{Algo de matemáticas}

Para poder implementar nuestra solución será necesario revisar un par de conceptos matemáticos. 

\subsubsection{Vectores}

Un vector es un objeto que tiene una magnitud y una dirección \cite{introVectors} \footnote{En español solemos decir que tienen módulo, dirección y sentido, pero nos ceñiremos a la definición anglosajona.}, gráficamente lo representamos como una \emph{flecha}.
 
 \begin{figure}[h!]
 	\centering
 	\includegraphics[width=6cm]{./Images/vector.png}
 	\caption{Representación gráfica de un vector.}
 	\label{vector}
 \end{figure}

Con los vectores podemos representar por ejemplo la velocidad en la que se mueve un personaje: la magnitud indicaría la rapidez y la dirección indicaría hacia dónde se está moviendo. En el computador esto lo podríamos representar de la siguiente forma:

\begin{enumerate}
\item Un ángulo ($\theta$) indicando \emph{la dirección}.

\item Un número ($v$) indicando \emph{la rapidez}.
\end{enumerate}


\subsubsection{Vector unitario}

Los vectores unitarios son aquellos cuya magnitud es 1, luego podemos utilizarlo cuando necesitamos saber sólamente la dirección en la que apunta el vector.

\begin{figure}[h!]
	\centering
	\includegraphics[width=6cm]{./Images/unitaria.png}
	\caption{Circunferencia unitaria.}
	\label{unitaria}
\end{figure}


Cuando tratamos problemas de dos dimensiones, nos referimos a la grafica \ref{unitaria}. De donde podemos sacar, dado un ángulo $\theta$, las componentes en X e Y del vector unitario que representa dicho ángulo.

\begin{equation}
\begin{aligned}
\label{unitvector}
ComponenteX = sin \theta \\
ComponenteY = cos \theta
\end{aligned}
\end{equation}

En otras palabras, dado un ángulo, al aplicar el \emph{sin} y el \emph{cos}, podemos obtener un vector unitario que apunta en la misma dirección. En breve, veremos cómo utilizar este concepto para darle movimiento al jugador y para disparar los \emph{raycast}.

\subsubsection{Radianes}

Los radianes es una unidad utilizada para representar ángulos. En los lenguajes de programación es más común que se utilicen \emph{radianes} en vez de \emph{grados} para la manipulación y operación de ángulos, dicho esto, las funciones como \emph{sin} y \emph{cos} en Python esperan recibir ángulo en \emph{radianes}. 

\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{./Images/radianes.png}
	\caption{¿Gráficamente qué son los radianes?}
	\label{rads}
\end{figure}

En la gráfica \ref{rads} vemos una intuición sobre lo que son los radianes. De la misma gráfica, es posible notar que $\pi$ radianes equivale a $180^{\circ}
$, luego $2\pi$ son $360^{\circ}$. Siguiendo la misma lógica, $\frac{\pi}{2}$ son  $90^{\circ}$.


Vistos todos los conceptos matemáticos necesarios, es hora de modelar realmente las fórmulas que nos permitirán construír nuestro \textbf{motor 3D}.

\subsection{Modelando el motor}

Para realizar el modelo matemático que dará forma a nuestro motor, construiremos las soluciones formalmente y al final de cada sección escribiremos el código de lo previamente analizado, de forma que sea posible aterrizar un poco más los conceptos. En el \autoref{chap:enlaces} (Enlaces adicionales) el lector podrá encontrar contenidos extra para profundizar este tópico.

Antes de continuar, cabe anotar que durante toda la ejecución tendremos acceso a los siguientes datos:

\begin{itemize}
	\item Posición del jugador: $jugador_x$ y $jugador_y$, dos números decimales.
	\item Dirección en la que está mirando el jugador, almacenada como un número decimal que representa ángulo en radianes: $jugador_{rot}$.
	\item La velocidad de movimiento y de rotación del jugador, almacenados como dos números decimales: $velocidad$,  $velocidad_{rot}$. 
	\item El campo de visión del jugador en radianes $FOV$ (Por sus siglas en inglés Field of View - Campo de Visión).
	\item La resolución de la pantalla, el alto y ancho de la pantalla.
	\item Una distacia máxima para limitar qué tan lejos mandamos los raycast.
	\item El mapa, una matriz que definiremos más adelante.
\end{itemize}

Luego los cálculos que realicemos, estarán basados en dichos valores. Lo anterior podríamos codificarlo en Python como se ve en el código \ref{cod-motor-vars}.

\lstinputlisting[language=Python,caption=Variables generales del programa con algunos valores posibles.,label=cod-motor-vars]{./py/motor-3d/variables.py}

\subsubsection{El movimiento del jugador}

Cuando se presione la tecla arriba el jugador se moverá hacia adelante en la dirección en la que él está mirando. Luego, deberíamos obtener un vector unitario a partir de la variable $jugador_{rot}$ , multiplicarlo por la $velocidad$ a la que se desplaza el jugador y sumarlo a su posición actual. Aplicaríamos este concepto a cada componente ($x$ e $y$) como se puede ver en las ecuaciones \ref{movforw}. Para que camine hacia atrás, en vez de sumar, restamos. 

\begin{equation}
\begin{aligned}
\label{movforw}
jugador_x = jugador_x \pm velocidad * sin(jugador_{rot})  \\
jugador_y = jugador_y \pm velocidad * cos(jugador_{rot})
\end{aligned}
\end{equation}

Finalmente, para la rotación, bastaría con sumar o restar \emph{la velocidad de rotación} a \emph{la rotación actual del jugador}.

\begin{equation}
\begin{aligned}
\label{eq-rot}
jugador_{rot} = jugador_{rot} \pm velocidad_{rot}
\end{aligned}
\end{equation}

\lstinputlisting[language=Python,caption=Movimiento del personaje de acuerdo a las teclas presionadas.,label=cod-motor-mov]{./py/motor-3d/movimiento.py}



\subsubsection{El raycast}

En nuestro caso, para poder realizar los \emph{Raycast} necesitamos saber en qué dirección dispararlo (para lo cuál usaríamos un vector unitario) y qué tan lejos hacerlo (de momento usaremos una variable llamada $distancia$ ya veremos cómo calcularla). Una simplificación que podemos hacer, es que como sabemos que el mapa está perfectamente alineado a una cuadrícula podemos omitir los decimales, para lo cuál usaremos la función \emph{floor} (que aproxima un número decimal a su entero más cercano por debajo). Todo esto lo podemos ver en la ecuación \ref{eqray}.

\begin{equation}
\begin{aligned}
\label{eqray}
rayo_x = floor(x + sin \theta * distancia)\\
rayo_y = floor(y + cos \theta * distancia)\\
\end{aligned}
\end{equation}

Hablando de la $distancia$, la calcularemos iniciando desde 0, e incrementándola poco a poco hasta llegar a un valor máximo o hasta que toquemos una pared (Ver imagen \ref{raycastit}). La idea de poner un límite máximo es optimizar un poco las cosas, si ya el rayo está muy grande y no hemos encontrado una pared, no queremos seguir buscando infinitamente, porque el juego se bloquearía.

\begin{figure}[h!]
	\centering
	\includegraphics[width=6cm]{./Images/raycast.png}
	\caption{Incrementando iterativamente la distancia del rayo hasta encontrar una pared o llegar a un límite máximo.}
	\label{raycastit}
\end{figure}

Para ver todo esto en Python, podemos utilizar un código como el \ref{cod-motor-raycast}. Nótese que para mayor órden, hemos definido las instrucciones como una función que podamos reutilizar. A dicha función le enviamos la coordenada $x$ e $y$ y la $rotacion$ desde la cuál disparar el rayo; al final recibimos la distancia en la cuál hubo colisión, o en su defecto el valor que hallamos configurado como distancia máxima del rayo. En cuanto a \emph{saber cuándo tocamos un muro}, simplemente llamamos una función que recibe las coordenadas del rayo y chequea si están dentro del mapa, de ser así revisa si dicha posición es o no un muro.

\lstinputlisting[language=Python,caption=Función para realizar un raycast.,label=cod-motor-raycast]{./py/motor-3d/raycast.py}

Notemos que el valor de \emph{math.sin(rot)} y \emph{math.cos(rot)}, será el mismo durante un llamado a la función, luego podríamos optimizar ligeramente nuestro código haciendo el cálculo previamente y reutilizando el valor, como se puede ver en el código \ref{cod-motor-raycast-opt}.

\newpage

\lstinputlisting[language=Python,caption=Optimizando ligeramente la función del raycast.,label=cod-motor-raycast-opt]{./py/motor-3d/raycast-opt.py}


\newpage

\subsubsection{Raycasts en el campo de visión}

\begin{figure}[h!]
	\centering
	\includegraphics[width=6cm]{./Images/fov.png}
	\caption{El campo de visión del jugador.}
	\label{fovgraph}
\end{figure}

Ahora, necesitamos calcular cómo mandar varios \emph{raycasts}, de forma que podamos dibujar todo el campo de visión (FOV) del jugador. Para este propósito, lo primero será hallar los angulos de inicio y fin, desde los cuáles lanzaremos los rayos. Llamémoslos $FOV_{inicio}$ y $FOV_{fin}$ .

De la gráfica \ref{fovgraph}, podemos ver que el inicio del FOV se encuentra restando la mitad del FOV total del ángulo al que está mirando el jugador ($\theta$, en el gráfico). Para el fin de FOV, sumamos la mitad del total del FOV al ángulo. Todo esto se ve en la ecuación \ref{foveq}. 

\begin{equation}
\begin{aligned}
\label{foveq}
FOV_{inicio} = jugador_{rot} - \frac{FOV}{2}\\
FOV_{fin} = jugador_{rot} + \frac{FOV}{2} \\
\end{aligned}
\end{equation}

A continuación, debemos tener en cuenta que el FOV es en definitiva lo que vamos a pintar en el ancho de la pantalla. Luego, debemos hallar la proporción entre el FOV y el ancho de la pantalla para saber cuánto espacio debería haber entre cada rayo, de forma que al final se cubra toda la pantalla.

\begin{equation}
\begin{aligned}
\label{foveq}
Rayo_{espaciado} = \frac{FOV}{Pantalla_{ancho}}
\end{aligned}
\end{equation}

Finalmente, deberíamos tirar un rayo en el equivalente a cada pixel horizontal de la pantalla empezando desde la $FOV_{inicio}$. Luego, debemos realizar la siguiente operación para $pixel$, desde 0 hasta el ancho de la pantalla:

\begin{equation}
\begin{aligned}
\label{eq-rayo}
Rayo_{angulo} = FOV_{inicio} + pixel * Rayo_{espaciado} 
\end{aligned}
\end{equation}

Reemplazando:

\begin{equation}
\begin{aligned}
\label{eq-rayo-2}
Rayo_{angulo} = \left(jugador_{rot} - \frac{FOV}{2} \right) + pixel * \left(\frac{FOV}{Pantalla_{ancho}}\right)
\end{aligned}
\end{equation}

Para el programa, bastaría con calcular el ángulo de cada uno de los rayos y utilizar la función \textbf{raycast} que definimos en la sección anterior, disparando el rayo desde la posición del jugador, en el ángulo que recién calculamos. Todo esto reflejado en el código \ref{raycasts-fov}.

\lstinputlisting[language=Python,caption=Raycasts para todo el campo de visión del jugador.,label=raycasts-fov]{./py/motor-3d/raycasts-fov.py}

\subsubsection{Pintando la pantalla}


Al dibujar la escena tenemos 3 partes en la pantalla, a saber: el techo, el piso y el muro.

\begin{figure}[h!]
	\centering
	\includegraphics[width=6cm]{./Images/partes-3d.png}
	\caption{Renderizado del campo de visión del jugador.}
	\label{partes-3d}
\end{figure}

El algoritmo de pintado será, más o menos el siguiente: 

\begin{enumerate}
\item Pintamos la mitad superior de la pantalla con color negro, para indicar cuál es el techo.
\item Pintamos la mitad inferior de la pantalla con color café, indicando el piso.
\item Pintamos los muros de acuerdo a la distancia calculada, teniendo presente que la sensación de perspectiva la obtenemos así: entre más cercano el muro, debemos pintar una franja verde más grande; a mayor distancia, más pequeña la franja verde.
\end{enumerate}

En esta parte nos valdremos de una función llamada \textbf{dibujar\_rectangulo} que recibe los siguientes parámetros:

\begin{itemize}
\item La coordenada en X de la pantalla donde se va a pintar el rectángulo.
\item La coordenada en Y de la pantalla donde se va a pintar el rectángulo.
\item El ancho del rectángulo.
\item El alto del rectángulo.
\item El color en RGB (Red-rojo, Green-verde, Blue-azul), representado como una tupla. Por ejemplo, los siguientes son algunos colores válidos:
	\begin{itemize}
	\item (0, 0, 0): negro.
	\item (255, 0, 0): rojo.
	\item (0, 255, 0): verde.
	\item (0, 0, 255): azul.
	\item (255, 255, 255): blanco.
	\end{itemize}
\end{itemize}

\subsubsection{El techo y el piso}

\begin{figure}[h!]
	\centering
	\includegraphics[width=10cm]{./Images/techo-piso.png}
	\caption{Pintado de los elementos básicos de la pantalla.}
	\label{techo-piso}
\end{figure}

Para dibujar el techo usaremos el color negro (0, 0, 0) y para el piso un color café (170, 85, 0). 

El techo es la mitad superior de la pantalla, luego debería pintarse como un rectángulo en la posición (0, 0), el tamaño debería ser de todo el ancho de la pantalla y de la mitad del alto de la misma; para el piso, el tamaño debería ser el mismo, pero la posición debería ser (0, mitad del alto de la pantalla). Lo anterior, reflejado en el código \ref{cod-motor-techo-piso}.

\newpage
\lstinputlisting[language=Python,caption=Código para pintar el techo y el piso.,label=cod-motor-techo-piso,basicstyle=\fontsize{9}{9}\selectfont\ttfamily]{./py/motor-3d/techo-piso.py}


\subsubsection{Los muros}

Con respecto a los muros, recordemos que lo más importante es que a mayor distancia, debería verse más pequeño. Es necesario resaltar, que en un motor real la distancia se calcula haciendo una proyección ortogonal al vector en la dirección exacta que está mirando el jugador, de esta forma se evita un efecto llamado \emph{fish-eye effect}. Sin embargo, en nuestro caso simplemente usaremos una fórmula para pintar que nos dará un buen efecto, sin necesidad de entrar en detalles adicionales.

\begin{figure}[h!]
	\centering
	\includegraphics[width=10cm]{./Images/techo-piso-muro.png}
	\caption{Cambio en las proporciones de los elementos de la pantalla de acuerdo a la distancia de los muros.}
	\label{techo-piso-muro}
\end{figure}

El cálculo, cómo se puede ver en la figuro \ref{techo-piso-muro}, es determinar el tamaño de la sección de techo y piso, de acuerdo a la distancia calculada contra el muro. Teniendo ese dato, podemos saber qué tan grande pintamos la sección verde de la pantalla.

Lo primero que podemos determinar es que el $techo$ y el $piso$ tienen el mismo tamaño, luego teniendo uno de ellos, sabremos el otro. Ahora, centrándonos en el techo, 


Para ayudar a dar más sensación de profundidad, haremos que entre más lejos esté el muro, no sólo sea más pequeño, si no que también se vea ligeramente más oscuro. El valor máximo del $techo$ es la mitad del alto de la pantalla (en caso de no haber muro, como se ve en la figura \ref{techo-piso}), a dicho valor le restaremos una proporción de la pantalla.

\begin{equation}
\begin{aligned}
\label{eq-techo}
techo = \frac{Pantalla_{alto}}{2} - ProporcionDistancia
\end{aligned}
\end{equation}

La proporción la podemos calcular de diferentes formas, sin embargo, una que funciona bien y no genera demasiados efectos ópticos extraños, es simplemente dividir el alto de la pantalla entre la distancia con respecto al muro. 

\begin{equation}
\begin{aligned}
\label{eq-propdist}
ProporcionDistancia = \left(\frac{Pantalla_{alto}}{distancia}\right)
\end{aligned}
\end{equation}

Reemplazando en la ecuación \ref{eq-techo} obtenemos la fórmula completa (\ref{eq-techo-completa}).

\begin{equation}
\begin{aligned}
\label{eq-techo-completa}
techo = \frac{Pantalla_{alto}}{2} - \left(\frac{Pantalla_{alto}}{distancia}\right)
\end{aligned}
\end{equation}

max 0

shading

dibujo codigo

\section{Código completo}