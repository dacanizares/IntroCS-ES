\chapter{Introducción a Python}

Luego de ver a grandes rasgos cómo programar un computador, llegó la hora de explorar lo que hemos aprendido en un lenguaje de programación real. 

Cómo vimos, los principales componentes de un computador son \emph{la entrada}, \emph{la salida}, \emph{la memoria} y \emph{el programa}. Ya que vamos a escribir nuestros programas en Python, surge una pregunta: ¿Cómo interactúa Python con los componentes de nuestro computador? Después de muchos intentos con distintas explicaciones, quizá la mejor forma de responder esta pregunta es mediante ejemplos reales en el lenguaje de programación. Se recomienda encarecidamente al lector, que pruebe todos los programas en su máquina, para que los vea en funcionamiento. De igual forma, nada de esto tendrá sentido si el lector pasa rápidamente sobre este libro y no se toma el tiempo para interiorizar cada instrucción.

Para aprender como instalar Python y cómo ejecutar los programas, revise el \autoref{chap:instalacion-python}: Instalación de Python.

\section{Las abstracciones básicas}

Comencemos por dar un intuición de qué es una \emph{abstracción}:

\emph{Una abstracción es un mecanismo que permite manipular una máquina sin necesidad de conocer a fondo su funcionamiento. Por ejemplo, el pedal de un carro permite que usted acelere sin necesidad de conocer el funcionamiento del motor}. 

En la programación de ordenadores, las abstracciones son un concepto sumamente útil porque nos permiten desarrollar nuestros programas sin necesidad de conocer todos los detalles de nuestras máquinas, así por ejemplo, para desarrollar un videojuego no necesitamos conocer exactamente cómo funciona una tarjeta gráfica para pintar dibujos en la pantalla, ni tampoco saber los pormenores de una tarjeta de sonido para reproducir una canción: existen ya abstracciones, así como los pedales de un carro, que de forma mucho más intuitiva nos permiten interactuar con dichos componentes.

Aunque en un computador todo termina siendo unos y ceros, Python tiene algunas abstracciones básicas (otras más avanzadas, que veremos en capítulos posteriores) que harán todo más fácil.

\subsection{Abstracciones de los datos}

En Python contamos con diferentes \textbf{tipos de datos} para determinar las acciones que podemos realizar con los valores almacenados en la memoria del computador. La ventaja es que no  necesitamos conocer a profundidad qué hace el computador con ellos, ni cómo los almacena, simplemente los utilizamos y operamos a conveniencia. Por ejemplo, si necesitáramos guardar un texto u operar un par de números, Python tiene abstracciones ya definidas para ellos. En la tabla \ref{tabla_tipos} podemos ver los principales tipos que existen.

\begin{table}[ht]
\centering
\begin{tabular}{ l c c c }
	
	\hline
	Tipo de dato & Python & Ejemplos de valores posibles \\
	\hline
	Números enteros & int  & 0, -1, 1, 40, 52,  \\ 
	Números con decimales & float & 0, 0.1, -0.2, 22.5 \\ 
	Valores lógicos & bool & True, False \\
	Texto & str & 'Esto es un texto!' \\
	\hline
	
\end{tabular}
\caption{Los principales tipos de datos básicos en Python.}
\label{tabla_tipos}
\end{table}

A continuación por diseccionar un poco cada grupo, empezando por los números (incluyendo a ambos, enteros y decimales).

\subsubsection{Números}

En Python, los enteros se llaman \textbf{int} (de \emph{integer}, en inglés) y los que tienen decimales se conocen como \textbf{float}. Permiten efectuar operaciones aritméticas, las más comunes son:

\begin{itemize}
\item Sumas (+): $5 + 2$ evalúa $7$.
\item Restas (-): $5 - 2$ evalúa $3$.
\item Multiplicaciones (*): $5 * 2$ evalúa $10$.
\item Divisiones (/): $5 / 2$ evalúa $2.5$.
\item Divisiones enteras (//): $5 // 2$ evalúa $2.5$.
\item Residuos (\%): $5 \% 2$ evalúa $1$.
\item Potencias (**): $5 ** 2$ evalúa $25$.
\end{itemize}

Las dos operaciones que se salen un poco del conocimiento general son las divisiones enteras y los residuos. Aclaremos para qué sirven: 

\begin{itemize}
\item Si luego de realizar una división queremos eliminar los decimales usamos el operador división entera (//). En el ejemplo: \emph{5 / 2} da como resultado \emph{2.5}; \emph{5 // 2} da como resultado \emph{2}.

\item Cuando hablamos de residuos, es el valor que sobra luego de realizar una división. En el ejemplo: Si dividimos 5 entre 2 el residuo es 1, luego \emph{5 \% 2} da como resultado \emph{1}.
\end{itemize}


\subsubsection{Valores lógicos}

Los valores lógicos se conocen en Python como \textbf{bool} (booleanos) y sólo tienen dos valores posibles verdadero (\textbf{True}) o falso (\textbf{False}). Podemos aplicar los operadores:

\newpage
\begin{itemize}
\item Y (\textbf{and}): Evalúa que dos valores sean verdaderos.
	\begin{itemize}
	\item $True$ and $True$ evalúa $True$.
	\item $True$ and $False$ evalúa $False$.
	\item $False$ and $True$ evalúa $False$ .
	\item $False$ and $False$ evalúa $False$ .
	\end{itemize}
\item  O(\textbf{or}): Evalúa que al menos uno de los valores sea verdadero.
	\begin{itemize}
	\item $True$ and $True$ evalúa $True$.
	\item $True$ and $False$ evalúa $True$.
	\item $False$ and $True$ evalúa $True$ .
	\item $False$ and $False$ evalúa $False$ .
	\end{itemize}
\item Negación (\textbf{not}): cambia el valor al contrario posible.
	\begin{itemize}
	\item not $True$ evalúa $False$.
	\item not $False$ $True$.
	\end{itemize}
\end{itemize}

Al igual que con una expresión aritmética, donde podemos mezclar sumas y restas (por decir un par de operaciones), con los valores lógicos podemos utilizar varios operadores para componer proposiciones más complejas, como por ejemplo, analizar si tres valores son verdaderos.

\subsubsection{Texto} 

Se conocen como \textbf{str} (strings) o secuencias de caracteres. Empiezan por una comilla doble o sencilla y terminan por el mismo símbolo, esto, con el fin de distinguir los textos arbitrarios definidos por el programador de otras instrucciones propias del lenguaje de programación (que en breve comenzaremos a poner en práctica).

Para los textos, en los programas podemos analizarlos y manipularlos utilizando diferentes operaciones y técnicas, tópico que revisaremos en el capítulo Qué es un Parser (FALTA: Referencia al capítulo). De momento sólo los utilizaremos para mostrar información útil en la pantalla, como veremos en breve.

\subsection{Abstracciones de la memoria}

Python no sólo facilita la representación de los datos en memoria, sino también su almacenamiento y manipulación. Para este fin introduciremos el concepto de \textbf{variables}.

\subsubsection{Las variables}

Permiten dar un nombre arbitrario y un valor a partes de la memoria utilizando el signo igual (=). Es importante aclarar que \emph{Python detecta automáticamente el tipo dato que se le asigna a una variable}, luego simplemente podemos realizar las asignaciones como se ve en el código \ref{cod-asignacion}. \\

\lstinputlisting[language=Python,caption=Asignaciones en Python,label=cod-asignacion]{./py/python/asignacion.py}

Existen tres restricciones que debemos tener en cuenta antes de nombrar una variable: usar únicamente letras, números o guiones bajos, no empezar por un número y no dejar espacios en blanco. Si esto no se cumple el código presentará un error.

Por otro lado, la forma más común de nombrar variables en Python, aunque no es obligatoria es recomendada: consiste en escribir todo en minúsculas y usar nombres \emph{descriptivos}, si el nombre son varias palabras se separan por guiones bajos. Si esto no se cumple el código aún funcionará, pero el programa será, probablemente, menos claro que si seguimos las recomendaciones. \\

Anotemos también que es posible realizar comentarios a nuestro código añadiendo el caracter \#, donde podemos escribir aclaraciones del programa, sin afectar su comportamiento.

En el fragmento \ref{cod-constantes} podemos ver ejemplos de nombramientos correctos, no recomendados e incorrectos. \\

\lstinputlisting[language=Python,caption=Ejemplos para nombres de variables,label=cod-asignacion]{./py/python/nombres.py}

Es también importante anotar, que en programas pequeños, como los ejemplos que veremos en breve, es posible que usemos nombres más cortos (como una letra, similar a cómo se hace en las expresiones matemáticas), para facilitar la manipulación de las variables; en programa más grandes, se privilegia en general el uso de nombres más largos y descriptivos.

\subsubsection{Las constantes}

Cuando estamos programando, es común encontrarnos con valores generales que no cambian durante la ejecución del código. Dichos valores los llamamos constantes, y aunque en Python no existe una distinción especial entre \emph{variables} y \emph{constantes}, se acostumbra a nombrarlos con MAYÚSCULAS\_SOSTENIDAS, de esta forma podemos distinguir fácilmente que valores NO deberíamos cambiar bajo ninguna circunstancia. \\

\lstinputlisting[language=Python,caption=Asignaciones en Python,label=cod-constantes]{./py/python/constantes.py}

Hasta este punto, si ejecutáramos alguno de los códigos anteriores en el computador no veríamos nada porque aún no hemos definido instrucciones para la salida de datos.

\subsection{Abstracciones de entrada y salida}

Las siguientes instrucciones nos permiten interactuar con el usuario de una forma básica.

\subsubsection{Salida de datos}

La forma básica de mostrar información en la pantalla es usando la instrucción \emph{print}. Basta con escribirla y dentro de paréntesis colocar el valor, la operación o variable que se desea mostrar. En caso de necesitar imprimir múltiples valores, se pueden poner separados por comas, como se ve en el fragmento \ref{cod-salida} \\

\newpage
\lstinputlisting[language=Python,caption=Salida de datos en Python,label=cod-salida]{./py/python/salida.py}

\subsubsection{Entrada de datos}

En cuanto a la entrada de datos básica, tenemos la instrucción \emph{input()}; entre los paréntesis se puede colocar un mensaje para que le aparezca al usuario. Luego de ingresar los caracteres por teclado y presionar la tecla \emph{enter}, los datos quedan almacenados en la variable a la cuál se haya asignado la instrucción. Sin embargo, hay que anotar que la instrucción \emph{input()} nos devuelve un \emph{string}(o texto), luego, si queremos hacer operaciones númericas, debemos convertir ese texto en un número. Dicha conversión se conoce con el nombre de \emph{casting}. De momento, usaremos alguna de las dos opciones que se ve en el fragmento \ref{cod-casting}. \\

\lstinputlisting[language=Python,caption=Algunos castings en Python,label=cod-casting]{./py/python/casting.py}

Por ejemplo, el código \ref{cod-suma} muestra como solicitar dos números por teclado para luego imprimir el valor que resulta al sumarlos \footnote{Si estamos esperando un número y el usuario ingresa una palabra, el programa terminará. Existen mecanismos de validación, pero por motivos pedagógicos, de momento omitiremos validaciones adicionales y nos centraremos en el proceso de construcción de nuestras soluciones.}. 

\textbf{Importante:} ¿Qué pasa si no convertimos las entradas en enteros? Se recomienda al lector que ensaye en su computador. Si quedan dudas, en la sección problemas de este capítulo podrá encontrar la respuesta. \\

\lstinputlisting[language=Python,caption=Lectura y suma de dos números en Python,label=cod-suma]{./py/python/suma.py}

\subsection{Abstracciones para el programa}

Existen dos mecanismos básicos para controlar el flujo de nuestro programa, a saber:

\begin{itemize}
\item Condicionar las instrucciones: es decir, indicar en qué casos se debería o no ejecutar una parte de nuestro código.
\item Repetir las instrucciones: para determinar fácilmente que bloques de nuestro código se deben ejecutar más de una vez.
\end{itemize}

Exploremos cómo realizar ambos mecanismos en Python.

\subsubsection{Condicionar las instrucciones}

Para este fin utilizamos la expresión \emph{if}, que traduce \emph{si} en español. Dicha expresión, debe ir acompañada de una \emph{condición}, que no es más que la evaluación, \emph{verdadera} o \emph{falsa}, de una proposición utilizando los operadores lógicos: es igual (==) \footnote{Nótese que se usa doble igual para distinguir la comparación de la asignación.}, mayor ($>$), menor($<$), mayor o igual ($>=$), menor o igual ($<=$) o diferente (!=). Por ejemplo, el código \ref{cod-if} sólo ejecuta la instrucción que imprime \emph{Es cero}, si  el valor ingresado es igual a 0. Las instrucciones que están condicionadas \textbf{deben ir tabuladas}, como se observa en el código de ejemplo, y pueden ser una o más instrucciones de cualquier tipo. \\

\lstinputlisting[language=Python,caption=Un \emph{if} en Python,label=cod-if]{./py/python/if.py}


La instrucción \emph{if} puede ir acompañada de un \emph{else}, que traduce \emph{si no} en español, y que se utiliza para indicar qué instrucciones ejecutar cuando la condición no se cumple. Esta situación se puede observar en el código \ref{cod-ifelse}, en el cuál se reciben dos números y se imprime cuál de ellos es el mayor (en caso de ser iguales, no importará cuál mostremos). Nótese que el texto entre comillas se muestra tal cuál en patalla, mientras que el valor después de la coma se reemplaza por el valor que tenga la variable en el momento de la ejecución. \\

\lstinputlisting[language=Python,caption=Un \emph{if-else} en Python,label=cod-ifelse]{./py/python/ifelse.py}

Si se necesitan condicionar más caminos, se puede utilizar la expresión \emph{elif}, que es una abreviación de \emph{else if}. Por ejemplo, si quisiéramos saber cuál es el mayor de tres números (llámense $a$, $b$ y $c$), habría tres opciones: 

\begin{itemize}
\item \emph{Si} $a$ es mayor que $b$ y que $c$, en tal caso, $a$ sería el mayor.

\item \emph{Si no}, se debe descartar entre $b$ y $c$ cuál es mayor, luego, \emph{si} $b$ es mayor que $c$, $b$ es el mayor.

\item \emph{Si no}, ninguna de las anteriores condiciones se cumple, es porque el mayor era $c$. 
\end{itemize}


Lo expresado anteriormente se observa en el código \ref{cod-ifelifelse}. Es importante resaltar en este punto, que si la condición es más compleja que evaluar un único valor, podemos usar los operadores \emph{and}, \emph{or} y \emph{not} para componer una expresión que sirva para representar el caso que necesitemos.   \\

\lstinputlisting[language=Python,caption=El mayor de tres números,label=cod-ifelifelse]{./py/python/ifelifelse.py}


\subsubsection{Repetición de instrucciones}

En cuanto a la repetición de instrucciones, se utiliza la instrucción \emph{for} \footnote{Entre otras que veremos en capítulos posteriores.}, que traduce \emph{para} en español. Veamos como funciona: \\

\lstinputlisting[language=Python,caption=Repetición de instrucciones en Python,label=cod-for]{./py/python/for.py}

El código anterior imprime los números desde el cero hasta el nueve (nótese que el límite superior \textbf{no} se incluye). Su lectura en español nos ayudará a entenderlo: \emph{para i en el rango de 0 a 10, imprima i}. La $i$ es una variable cualquiera, por lo cuál podemos utilizar otro nombre; es común usar $i$ por su relación con los índices y subíndices en matemáticas. Los dos números dentro del paréntesis de \emph{range} indican desde que valor inicia la repetición y en cuál termina. Al igual que con la estructura \emph{if}, las instrucciones que se repiten deben ir tabuladas.

Si quisieramos mostrar los números en un rango digitado por el usuario, donde \emph{a} es el límite inferior y \emph{b} es el límite superior, podríamos contruir un programa como el que se ve en el fragmento \ref{cod-for-rango}.

\lstinputlisting[language=Python,caption=El mayor de tres números,label=cod-for-rango]{./py/python/for-rango.py}

Es posible mezclar no sólo las instrucciones de entrada y salida, si no también todas las demás que hemos visto (y las que veremos), por ejemplo, tener programas como el del código \ref{cod-forif} que recibe dos números, imprime todos los enteros que hay entre ellos, indicando si son negativos o positivos. \\


\lstinputlisting[language=Python,caption=Repeticiones y decisiones en Python,label=cod-forif]{./py/python/forif.py}

Con estas abstracciones, tendríamos cubierto las herramientas más básicas de la programación de ordenadores en Python. Para que todo esto tenga sentido, es necesario prácticar, luego pasemos a la sección de problemas para poner las neuronas a prueba.

\section{Problemas}



\newpage