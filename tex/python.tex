\chapter{Introducción a Python}

Luego de ver a grandes rasgos cómo programar un computador, llegó la hora de explorar lo que hemos aprendido en un lenguaje de programación real. 

Cómo vimos, los principales componentes de un computador son \emph{la entrada}, \emph{la salida}, \emph{la memoria} y \emph{el programa}. Ya que vamos a escribir nuestros programas en Python, surge una pregunta: ¿Cómo interactúa Python con los componentes de nuestro computador? Después de muchos intentos con distintas explicaciones, quizá la mejor forma de responder esta pregunta es mediante ejemplos reales en el lenguaje de programación. Se recomienda encarecidamente al lector, que pruebe todos los programas en su máquina, para que los vea en funcionamiento. De igual forma, nada de esto tendrá sentido si el lector pasa rápidamente sobre este libro y no se toma el tiempo para interiorizar cada instrucción.

\section{Las abstracciones básicas}

Comencemos por dar un intuición de qué es una \emph{abstracción}:

\emph{Una abstracción es un mecanismo que permite manipular una máquina sin necesidad de conocer a fondo su funcionamiento. Por ejemplo, el pedal de un carro permite que usted acelere sin necesidad de conocer el funcionamiento del motor}. 

En la programación de ordenadores, las abstracciones son un concepto sumamente útil porque nos permiten desarrollar nuestros programas sin necesidad de conocer todos los detalles de nuestras máquinas, así por ejemplo, para desarrollar un videojuego no necesitamos conocer exactamente cómo funciona una tarjeta gráfica para pintar dibujos en la pantalla, ni tampoco saber los pormenores de una tarjeta de sonido para reproducir una canción: existen ya abstracciones, así como los pedales de un carro, que de forma mucho más intuitiva nos permiten interactuar con dichos componentes.

Aunque en un computador todo termina siendo unos y ceros, Python tiene algunas abstracciones básicas (otras más avanzadas, que veremos en capítulos posteriores) que harán todo más fácil.

\subsection{Abstracciones de los datos}

En Python contamos con diferentes \textbf{tipos de datos} para determinar las acciones que podemos realizar con los valores almacenados en la memoria del computador. La ventaja es que no  necesitamos conocer a profundidad qué hace el computador con ellos, ni cómo los almacena, simplemente los utilizamos y operamos a conveniencia. Por ejemplo, si necesitáramos guardar un texto u operar un par de números, Python tiene abstracciones ya definidas para ellos. En la tabla \ref{tabla_tipos} podemos ver los principales tipos que existen.

\begin{table}[ht]
\centering
\begin{tabular}{ l c c c }
	
	\hline
	Tipo de dato & Python & Ejemplos de valores posibles \\
	\hline
	Números enteros & int  & 0, -1, 1, 40, 52,  \\ 
	Números con decimales & float & 0, 0.1, -0.2, 22.5 \\ 
	Valores lógicos & bool & True, False \\
	Texto & str & 'Esto es un texto!' \\
	\hline
	
\end{tabular}
\caption{Los principales tipos de datos básicos en Python.}
\label{tabla_tipos}
\end{table}

A continuación por diseccionar un poco cada grupo, empezando por los números (incluyendo a ambos, enteros y decimales).

\subsubsection{Números}

En Python, los enteros se llaman \textbf{int} (de \emph{integer}, en inglés) y los que tienen decimales se conocen como \textbf{float}. Permiten efectuar operaciones aritméticas, las más comunes son:

\begin{itemize}
\item Sumas (+): $5 + 2$ evalúa $7$.
\item Restas (-): $5 - 2$ evalúa $3$.
\item Multiplicaciones (*): $5 * 2$ evalúa $10$.
\item Divisiones (/): $5 / 2$ evalúa $2.5$.
\item Divisiones enteras (//): $5 // 2$ evalúa $2.5$.
\item Residuos (\%): $5 \% 2$ evalúa $1$.
\item Potencias (**): $5 ** 2$ evalúa $25$.
\end{itemize}

Las dos operaciones que se salen un poco del conocimiento general son las divisiones enteras y los residuos. Aclaremos para qué sirven: 

\begin{itemize}
\item Si luego de realizar una división queremos eliminar los decimales usamos el operador división entera (//). En el ejemplo: \emph{5 / 2} da como resultado \emph{2.5}; \emph{5 // 2} da como resultado \emph{2}.

\item Cuando hablamos de residuos, es el valor que sobra luego de realizar una división. En el ejemplo: Si dividimos 5 entre 2 el residuo es 1, luego \emph{5 \% 2} da como resultado \emph{1}.
\end{itemize}


\subsubsection{Valores lógicos}

Los valores lógicos se conocen en Python como \textbf{bool} (booleanos) y sólo tienen dos valores posibles verdadero (\textbf{True}) o falso (\textbf{False}). Podemos aplicar los operadores:

\newpage
\begin{itemize}
\item Y (\textbf{and}): Evalúa que dos valores sean verdaderos.
	\begin{itemize}
	\item $True$ and $True$ evalúa $True$.
	\item $True$ and $False$ evalúa $False$.
	\item $False$ and $True$ evalúa $False$ .
	\item $False$ and $False$ evalúa $False$ .
	\end{itemize}
\item  O(\textbf{or}): Evalúa que al menos uno de los valores sea verdadero.
	\begin{itemize}
	\item $True$ and $True$ evalúa $True$.
	\item $True$ and $False$ evalúa $True$.
	\item $False$ and $True$ evalúa $True$ .
	\item $False$ and $False$ evalúa $False$ .
	\end{itemize}
\item Negación (\textbf{not}): cambia el valor al contrario posible.
	\begin{itemize}
	\item not $True$ evalúa $False$.
	\item not $False$ $True$.
	\end{itemize}
\end{itemize}

Al igual que con una expresión aritmética, donde podemos mezclar sumas y restas (por decir un par de operaciones), con los valores lógicos podemos utilizar varios operadores para componer proposiciones más complejas, como por ejemplo, analizar si tres valores son verdaderos.

\subsubsection{Texto} 

Se conocen como \textbf{str} (strings) o secuencias de caracteres. Empiezan por una comilla doble o sencilla y terminan por el mismo símbolo, esto, con el fin de distinguir los textos arbitrarios definidos por el programador de otras instrucciones propias del lenguaje de programación (que en breve comenzaremos a poner en práctica).

Para los textos, en los programas podemos analizarlos y manipularlos utilizando diferentes operaciones y técnicas, tópico que revisaremos en el capítulo Qué es un Parser (FALTA: Referencia al capítulo). De momento sólo los utilizaremos para mostrar información útil en la pantalla, como veremos en breve.

\subsection{Abstracciones de la memoria}

Python no sólo facilita la representación de los datos en memoria, sino también su almacenamiento y manipulación. Para este fin introduciremos el concepto de \textbf{variables}.

\subsubsection{Las variables}

Permiten dar un nombre arbitrario \footnote{Hay tres pequeñas restricciones que debemos tener en cuenta: usar únicamente letras, números o guiones bajos, no empezar por un número y no dejar espacios en blanco} y un valor a partes de la memoria utilizando el signo igual (=). Es importante aclarar que \emph{Python detecta automáticamente el tipo dato que se le asigna a una variable}, luego simplemente podemos realizar las asignaciones como se ve en el código \ref{cod-asignacion}. \\

\lstinputlisting[language=Python,caption=Asignaciones en Python,label=cod-asignacion]{./py/nociones/asignacion.py}

La forma más común de nombrar variables en Python, aunque no es obligatoria es recomendada: consiste en escribir todo en minúsculas y si el nombre son varias palabras, se separan por guiones bajos.

FALTA: ejemplo.

\subsubsection{Las constantes}

Cuando estamos programando, es común encontrarnos con valores generales que no cambian durante la ejecución del código. Dichos valores los llamamos constantes, y aunque en Python no existe una distinción especial entre \emph{variables} y \emph{constantes}, se acostumbra a nombrarlos con MAYÚSCULAS\_SOSTENIDAS, de esta forma podemos distinguir fácilmente que valores NO deberíamos cambiar bajo ninguna circunstancia.

FALTA: ejemplo.

Si ejecutamos alguno de los códigos anterior en el computador no veremos nada porque aún no hemos definido instrucciones para la salida de datos.

\subsection{Abstracciones de entrada y salida}

La forma básica de mostrar información en la pantalla es usando la instrucción \emph{print}. Basta con escribirla y dentro de paréntesis colocar el valor, la operación o la variable que se desea mostrar. En Python podemos comentar el código, añadiendo el caracter \#, de forma que podamos escribir aclaraciones del programa, sin afectar su comportamiento. Todo lo anterior se ve en el código \ref{cod-salida}. \\


\lstinputlisting[language=Python,caption=Salida de datos en Python,label=cod-salida]{./py/nociones/salida.py}

Por otro lado, la entrada de datos básica se hace con la instrucción \emph{input()}; entre los paréntesis se puede colocar un mensaje para que le aparezca al usuario. Luego de ingresar los caracteres por teclado y presionar la tecla \emph{enter}, los datos quedan almacenados en la variable a la cuál se haya asignado la instrucción. Sin embargo, hay que anotar que la instrucción \emph{input()} nos devuelve un \emph{string}(o texto), luego, si queremos hacer operaciones númericas, debemos convertir ese texto en un número usando alguna de las dos siguientes opciones:

\begin{itemize}
 \item Convertir una entrada a entero: 
 \begin{lstlisting}[language=Python]
 entero = int(input('Digite un entero')) \end{lstlisting}
 \item Convertir una entrada a decimal:
 \begin{lstlisting}[language=Python]
 decimal = float(input('Digite un decimal')) \end{lstlisting}
\end{itemize}

 Por ejemplo, el código \ref{cod-suma} muestra como solicitar dos números por teclado para luego imprimir el valor que resulta al sumarlos \footnote{REVISAR: Como lo importante es aprender, por ahora confiaremos en que el usuario no cometerá errores al ingresar los datos. Algunos libros complican al estudiante obligándole a realizar un montón de validaciones antes de poder hacer cualquier cosa, bajo la excusa de que eso no se puede omitir en un programa comercial. Eso no tiene sentido, al fin y al cabo, cuando se realizan programas grandes, se usan otras herramientas que ayudan a prevenir estos errores. En capítulos posteriores exploraremos cómo hacerlo.}. \textbf{Importante:} Qué pasa si no convertimos las entradas en enteros? Se recomienda al lector que ensaye en su computador. Si quedan dudas en la sección problemas de este capítulo podrá encontrar la respuesta. \\

\lstinputlisting[language=Python,caption=Lectura y suma de dos números en Python,label=cod-suma]{./py/nociones/suma.py}

En Python también es posible condicionar la ejecución de ciertas instrucciones utilizando la expresión \emph{if}, que traduce \emph{si} en español. Dicha expresión, debe ir acompañada de una \emph{condición}, que no es más que la evaluación, \emph{verdadera} o \emph{falsa}, de una proposición utilizando los operadores lógicos: es igual (==) \footnote{Nótese que se usa doble igual para distinguir la comparación de la asignación.}, mayor ($>$), menor($<$), mayor o igual ($>=$), menor o igual ($<=$) o diferente (!=). Por ejemplo, el código \ref{cod-if} sólo ejecuta la instrucción que imprime \emph{Es cero}, si  el valor ingresado es igual a 0. Las instrucciones que están condicionadas \textbf{deben ir tabuladas}, como se observa en el código de ejemplo, y pueden ser una o más instrucciones de cualquier tipo. \\

\lstinputlisting[language=Python,caption=Un \emph{if} en Python,label=cod-if]{./py/nociones/if.py}


La instrucción \emph{if} puede ir acompañada de un \emph{else}, que traduce \emph{si no} en español, y que se utiliza para indicar qué instrucciones ejecutar cuando la condición no se cumple. Esta situación se puede observar en el código \ref{cod-ifelse}, en el cuál se reciben dos números y se imprime cuál de ellos es el mayor (en caso de ser iguales, no importará cuál mostremos). Nótese que el texto entre comillas se muestra tal cuál en patalla, mientras que el valor después de la coma se reemplaza por el valor que tenga la variable en el momento de la ejecución. \\

\lstinputlisting[language=Python,caption=Un \emph{if-else} en Python,label=cod-ifelse]{./py/nociones/ifelse.py}

Si se necesitan condicionar más caminos, se puede utilizar la expresión \emph{elif}, que es una abreviación de \emph{else if}. Por ejemplo, si quisiéramos saber cuál es el mayor de tres números (llámense $a$, $b$ y $c$), habría tres opciones: 
\begin{itemize}
\item Si $a$ es mayor que $b$ y que $c$, en tal caso, $a$ sería el mayor.

\item Si no, se debe descartar entre $b$ y $c$ cuál es mayor, luego, si $b$ es mayor que $c$, $b$ es el mayor.

\item Si ninguna de las anteriores condiciones se cumple, es porque el mayor era $c$. 
\end{itemize}


Lo expresado anteriormente se observa en el código \ref{cod-ifelifelse}.  \\

\lstinputlisting[language=Python,caption=El mayor de tres números,label=cod-ifelifelse]{./py/nociones/ifelifelse.py}

En cuanto a la repetición de instrucciones, se utiliza la instrucción \emph{for}, que traduce \emph{para} en español. Veamos como funciona: \\

\lstinputlisting[language=Python,caption=Repetición de instrucciones en Python,label=cod-for]{./py/nociones/for.py}

El código anterior imprime los números desde el cero hasta el nueve (nótese que el límite superior \textbf{no} se incluye). Su lectura en español nos ayudará a entenderlo: \emph{para i en el rango de 0 a 10, imprima i}. La $i$ es una variable cualquiera, por lo cuál podemos utilizar otro nombre; es común usar $i$ por su relación con los índices y subíndices en matemáticas. Los dos números dentro del paréntesis de \emph{range} indican desde que valor inicia la repetición y en cuál termina. Al igual que con la estructura \emph{if}, las instrucciones que se repiten deben ir tabuladas.

Es posible mezclar todas las instrucciones que hemos visto (y las que veremos), por ejemplo, tener programas como el del código \ref{cod-forif} que recibe dos números, imprime todos los enteros que hay entre ellos, indicando si son negativos o positivos.


\lstinputlisting[language=Python,caption=Repeticiones y decisiones en Python,label=cod-forif]{./py/nociones/forif.py}



\section{Problemas}



\newpage