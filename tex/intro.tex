\chapter{Introducción}

\begin{quote}
\emph{Ya sea que quieras desvelar los secretos del universo, o quieras hacer una carrera [en ciencias de la computación], la programación básica de computadores es una habilidad esencial por aprender en el siglo XXI.} \\
Stephen Hawking.
\end{quote}

Los esfuerzos humanos por crear máquinas para realizar cómputos de manera automática datan de muchos siglos atrás, pero no fue sino hasta la \emph{Segunda Guerra Mundial} que se contó con el dinero y los componentes necesarios para construir máquinas programables \cite[p.~108]{evansIntro}. En un comienzo su uso fue meramente bélico, las tareas más comunes estaban relacionadas con cálculos de trayectorias para cohetes balísticos. Sin embargo, estás máquinas marcaron un punto de inflexión en la historia de la humanidad: por primera vez un mismo aparato servía para casi cualquier propósito (siempre y cuándo éste fuese \emph{computable}, discusión que abordaremos en el último capítulo de este libro).

Parece increíble, pero los computadores que tenemos en la actualidad están basados en el mismo modelo que planteó Alan Turing en la década de 1930. A grandes rasgos, solamente tenemos equipos más rápidos y con más memoria. Esa mayor capacidad de cómputo nos permite contar con programas cada vez más sofisticados, pero también con herramientas que hacen más fácil nuestra tarea como programadores.
 \newpage

\begin{wrapfigure}{r}{0.5\textwidth}
	\begin{center}
	\includegraphics[width=0.5\textwidth]{./Images/eniac.png}
	\end{center}	
	\caption{El ENIAC, uno de los primeros computadores de la historia.}
\end{wrapfigure}

En este sentido, la programación de los primeros computadores era bastante difícil y se realizaba básicamente conectando y desconectando cables. Conforme avanzó el tiempo y aumentó la capacidad de cómputo, aparecieron los \textbf{compiladores}. Básicamente lo que hacen es tomar un programa de computador escrito en un lenguaje que es más fácil de entender para los humanos (\emph{lenguaje de alto nivel}), lo traducen a un lenguaje que sea más cercano al que entiende la máquina (\emph{lenguaje de bajo nivel}), produciendo lo que conocemos como un \emph{ejecutable}. Al final del día, un programa termina siendo una secuencia de bits (unos y ceros) que representan una serie de instrucciones que puede ejecutar la máquina. Los primeros compiladores fueron desarrollados por la Almirante Grace Hopper en la década de 1950.

Existe otro tipo de programas que realizan una tarea similar, pero a diferencia de los compiladores que toman el código y lo traducen completamente, los \textbf{intérpretes} realizan lo que podríamos llamar una \emph{traducción en simultáneo}. 

Cada enfoque tiene sus ventajas y desventajas: el código compilado es más rápido (gracias a la traducción previa que se realiza) pero en el código interpretado es más ágil el proceso de realizar cambios y ver cómo estos afectan la ejecución del programa.

El mecanismo utilizado para traducir los códigos a instrucciones que entiende la máquina es una forma en la cuál podemos clasificar los lenguajes de programación, sin embargo no es la única: la forma en que resolvemos problemas es una clasificación recurrente con la que nos encontraremos. A saber, existen dos grandes corrientes: la \textbf{programación imperativa} y la \textbf{programación funcional}. El enfoque de la primera es escribir instrucciones para modificar el estado de la memoria del computador, hasta eventualmente llegar a un estado que contenga la solución del problema. Por su parte, la programación funcional está relacionada con conceptos mucho más cercanos a las matemáticas, que en general tienen que ver con la aplicación de funciones que no manejan estado y que pueden \emph{componerse} para llegar a la solución. Obviamente ambos conceptos son mucho más profundos y los iremos explorando a medida que avancemos en los tópicos propuestos.

En la realidad nos encontraremos con programas que mezclan lenguajes compilados e interpretados. Por lo general, las partes más críticas de los sistemas son escritas en lenguajes compilados como \emph{C++} y son extendidas por lenguajes interpretados como \emph{Python} o \emph{Lua}. De igual forma, se deberían mezclar y aplicar técnicas propias de cada enfoque (imperativo y funcional), explotando al máximo las ventajas de ambos.

En este libro usaremos \emph{Python}, un lenguaje simple pero poderoso: interpretado, imperativo y con ciertos toques de programación funcional. Sin embargo, cabe anotar, que la mayoría de conceptos aquí expuestos pueden utilizarse en otros lenguajes, y que lo más importante no es la tecnología aplicada en un programa específico. La forma de aproximarse y construir soluciones computacionales, es lo que realmente debería importarle al lector.


