\chapter{Nociones básicas}

En este capítulo se veremos algunos de los conceptos involucrados en la programación de ordenadores a nivel básico. No se pretende que el lector los domine con sólo ver este capítulo, al contrario, la idea es dar un vistazo general sobre lo que utilizaremos y profundizaremos a lo largo del libro, de forma que, teniendo una imagen más completa de la programación los temas a tratar no parezcan obstáculos sin sentido, que sólo tienden a ralentizar el proceso de aprendizaje. 

Lo primero será comprender cómo las instrucciones de un programa operan directamente en la máquina, para esto introduciremos un modelo abstracto que representará nuestro computador: la Máquina de Acceso Aleatorio (RAM, por sus siglas en inglés).

\section{Máquina RAM}

\begin{figure}[h!]
	\centering
	\includegraphics[width=10cm]{./Images/ram.png}
	\caption{Máquina RAM}
	\label{figram}
\end{figure}


La idea es mantener el modelo lo más simple posible, razón por la cuál sólo consideraremos los siguientes componentes:

\begin{itemize}
\item La memoria: representa el estado de la máquina en un momento del tiempo. Está dividida en múltiples secciones que llamamos posiciones de memoria, cada posición tiene asociados un número (generalmente un hexadecimal) que permite distinguir las posiciones entre sí y un valor, que representa el dato almacenado.

\item La entrada: son los datos sobre los cuáles se va a operar, estos pueden ingresar representados por: una pulsación del teclado, un clic, información que viaja por Internet, la señales de un sensor, etc.
 
\item El programa: es una secuencia de instrucciones que le dice a la máquina cómo modificar su memoria de acuerdo a la entrada que recibe y al estado mismo de la memoria. 

\item La salida: es el resultado que se obtiene después de ejecutar total o parcialmente el programa. Decimos \emph{parcialmente}, porque no tenemos que esperar hasta el final para compartir información con el usuario, por ejemplo, durante la ejecución podemos ir mostrando una barra de carga o mostrando mensajes sobre los datos que estamos procesando.
\end{itemize}



De una u otra forma, el programa tendrá que interactuar con todos los componentes de la máquina, luego, los lenguajes de programación deben proveer mecanismos para manipular y representar la memoria, la entrada y la salida de datos. Cabe anotar que, como el programa depende del estado actual de la máquina, también se debería contar con estructuras que permitan repetir o ejecutar ciertas instrucciones de acuerdo a los datos almacenados en memoria. Por ejemplo, se deben ejecutar algunas instrucciones si la máquina entra o en un estado de error o se deben repetir algunas instrucciones mientras que una persona esté presionando una tecla en un videojuego. A propósito veamos con un ejemplo práctico todos estos conceptos.


\subsection{Ejemplo práctico}


\begin{figure}[h!]
	\centering
	\includegraphics[width=12cm]{./Images/pong.png}
	\caption{El legendario PONG.}
	\label{figpong}
\end{figure}

Supongamos un videojuego sencillo como \emph{Pong} (ver figura \ref{figpong}). El juego es una especie de \emph{tenis} en el que dos jugadores, cada uno en control de una barra que representa una raqueta, deben golpear una pelota e intentar que el otro jugador no alcance a responder el golpe, para marcar un punto. 

Intentemos comprender cómo representar este juego en nuestra \emph{Máquina RAM}. No lo haremos de forma exhaustiva pero un bosquejo, que permita entender a nivel general las mecánicas de la programación. Empecemos de lo más fácil a lo más complejo:

\begin{itemize}

	
	\item La entrada: en este caso la entrada serían las teclas que presionan los jugadores para mover arriba y abajo cada una de las raquetas.
	
	\item La salida: son los gráficos que vemos en la pantalla y que representan lo que está pasando en estado de la máquina mientras simula el videojuego.
	
	\item La memoria: para poder representar el estado del juego en la máquina es necesario tener espacios de memoria donde guardemos:
	
	\begin{itemize}
		\item La puntuación del jugador 1.
		\item La puntuación del jugador 2.
		\item La posición de la raqueta del jugador 1.
		\item La posición de la raqueta del jugador 2.
		\item La posición de la pelota.
		\item No sólo la posición, si no también la velocidad y dirección de la pelota.
	\end{itemize}

	Con todos estos datos, es posible saber el estado del juego y así, el computador puede pintar en pantalla qué es exactamente lo que está pasando.
	
	\item El programa: para que nuestra máquina simule realmente el videojuego tendríamos que tener en cuenta darle instrucciones para cada uno de los siguientes casos: 
	
	\begin{itemize}
		\item Si el jugador 1 presione la tecla arriba, mover la posición de su raqueta hacia arriba; cada vez que presione la tecla abajo, mover su raqueta hacia abajo. De igual forma habría que configurar un par de teclas para que el jugador 2 pueda moverse.
		
		\item Mover la posición de la pelota de acuerdo a su velocidad y dirección.
		
		\item Si la pelota colisiona con una raqueta, cambiar su dirección.
		
		\item Si la pelota toca la esquina izquierda, sumar más uno a la puntuación del jugador 1; si la pelota toca la esquina derecha, sumar a la puntuación del jugador 2.
		
		\item Luego de todo esto, pintar en la pantalla las raquetas, la pelota y la puntuación.
		
		\item Repetir desde el primer paso, hasta que los jugadores se salgan del juego.
	\end{itemize}
\end{itemize}





Ahora, la pregunta es: ¿Cómo hace todo esto Python en un computador real? Después de muchos intentos con distintas explicaciones, creo que la mejor forma de responder esta pregunta es mediante ejemplos reales en el lenguaje de programación. Se recomienda encarecidamente al lector, que pruebe todos los programas en su máquina, para que los vea en funcionamiento. De igual forma, nada de esto tendrá sentido si el lector pasa rápidamente sobre este libro y no se toma el tiempo para entender qué hace cada instrucción.

\section{Programación en Python}

Aunque en un computador todo termina siendo unos y ceros, Python tiene algunas abstracciones básicas (otras un poco más avanzadas, que veremos en el capítulos posteriores) que harán todo más fácil. Una abstracción permite manipular la máquina sin necesidad de conocer a fondo su funcionamiento. Por ejemplo, el pedal de un carro permite que usted acelere sin necesidad de conocer el funcionamiento del motor. Si hablamos de la memoria, en Python contamos con diferentes \textbf{tipos de datos} que determinan las acciones podemos realizar con los datos almacenados en memoria, sin necesidad de conocer a profundidad qué hace el computador con ellos. A saber:

\begin{itemize}
\item Números: con los números podemos efectuar operaciones aritméticas como sumas (+), restas (-), multiplicaciones (*), divisiones(/), residuos(\%) y potencias (**). En Python, los enteros se llaman \textbf{int} (de \emph{integer}, en inglés) y los que tienen decimales se conocen como \textbf{float}. Por ejemplo: 0, -1, 1, 40, 52, son enteros y 0.1, 0.7, -1.8 son decimales.

\item Valores lógicos: en Python se conocen como \textbf{bool} (booleanos) y sólo tienen dos valores posibles: verdadero (\textbf{True}) o falso (\textbf{False}). Podemos aplicar los operadores Y (\textbf{and}), O(\textbf{or}), Negación (\textbf{not}), entre otros, para componer proposiciones más complejas.  Ver código \ref{cod-asignacion}.

\item Texto: se conocen como \textbf{strings} o secuencias de caracteres. Empiezan por una comilla doble o sencilla y terminan por el mismo símbolo, esto, con el fin de distinguir los textos arbitrarios definidos por el programador de las instrucciones propias del programa. Ver código \ref{cod-asignacion}.
\end{itemize}

Python no sólo facilita la representación de los datos en memoria, sino también su almacenamiento y manipulación. Para esto, existe el concepto de \textbf{variables}, que permiten dar un nombre arbitrario \footnote{Sólo hay tres restricciones: usar únicamente letras, números o guiones bajos, no empezar por un número y no dejar espacios en blanco} y un valor a partes de la memoria solamente utilizando el operador de igualdad (=), como se ve en el código \ref{cod-asignacion}. Python detecta automáticamente el tipo dato que se le asigna a una variable. \\

\newpage

\lstinputlisting[language=Python,caption=Asignaciones en Python,label=cod-asignacion]{./py/nociones/asignacion.py}

Si ejecutamos ese código, el computador no mostrará nada, eso es porque aún no hemos definido instrucciones para la salida de datos. La forma básica de mostrar información en la pantalla es usando la instrucción \emph{print}. Basta con escribirla y seguido de un espacio colocar el valor, la operación o la variable que se desea mostrar. En Python podemos comentar el código, añadiendo el caracter \#, de forma que podamos escribir aclaraciones del programa, sin afectar su comportamiento. Todo lo anterior se ve en el código \ref{cod-salida}. \\


\lstinputlisting[language=Python,caption=Salida de datos en Python,label=cod-salida]{./py/nociones/salida.py}

Por otro, la entrada de datos básica se hace con la instrucción \emph{input()}; entre los paréntesis se puede colocar un mensaje para aparezca a la persona que ejecuta el programa. Luego de ingresar los caracteres por teclado y presionar la tecla \emph{enter}, los datos quedan almacenados en la variable a la cuál se haya asignado la instrucción. Por ejemplo, el código \ref{cod-suma} muestra como solicitar dos números por teclado para luego imprimir el valor que resulta al sumarlos \footnote{Como lo importante es aprender, por ahora confiaremos en que el usuario no cometerá errores al ingresar los datos. He visto códigos que complican al estudiante con mil y una validaciones, bajo la excusa de que eso no se puede omitir en un programa comercial. Eso no tiene sentido, al fin y al cabo, cuando se realizan programas grandes, se usan otras herramientas que ayudan a prevenir estos errores.}. \\

\newpage

\lstinputlisting[language=Python,caption=Lectura y suma de dos números en Python,label=cod-suma]{./py/nociones/suma.py}

En Python también es posible condicionar la ejecución de ciertas instrucciones utilizando la expresión \emph{if}, que traduce \emph{si} en español. Dicha expresión, debe ir acompañada de una \emph{condición}, que no es más que la evaluación, \emph{verdadera} o \emph{falsa}, de una proposición utilizando los operadores lógicos: es igual (==) \footnote{Nótese que se usa doble igual para distinguir la comparación de la asignación.}, mayor ($>$), menor($<$), mayor o igual ($>=$), menor o igual ($<=$) o diferente (!=). Por ejemplo, el código \ref{cod-if} sólo ejecuta la instrucción que imprime \emph{Es cero}, si  el valor ingresado es igual a 0. Las instrucciones que están condicionadas \textbf{deben ir tabuladas}, como se observa en el código de ejemplo, y pueden ser una o más instrucciones de cualquier tipo. \\

\lstinputlisting[language=Python,caption=Un \emph{if} en Python,label=cod-if]{./py/nociones/if.py}


La instrucción \emph{if} puede ir acompañada de un \emph{else}, que traduce \emph{si no} en español, y que se utiliza para indicar qué instrucciones ejecutar cuando la condición no se cumple. Esta situación se puede observar en el código \ref{cod-ifelse}, en el cuál se reciben dos números y se imprime cuál de ellos es el mayor (en caso de ser iguales, no importará cuál mostremos). Nótese que el texto entre comillas se muestra tal cuál en patalla, mientras que el valor después de la coma se reemplaza por el valor que tenga la variable en el momento de la ejecución. \\

\lstinputlisting[language=Python,caption=Un \emph{if-else} en Python,label=cod-ifelse]{./py/nociones/ifelse.py}

Si se necesitan condicionar más caminos, se puede utilizar la expresión \emph{elif}, que es una abreviación de \emph{else if}. Por ejemplo, si quisiéramos saber cuál es el mayor de tres números (llámense $a$, $b$ y $c$), habría tres opciones: 
\begin{itemize}
\item Que $a$ sea mayor que $b$ y que $c$, en tal caso, $a$ sería el mayor.

\item Si no, se debe descartar entre $b$ y $c$ cuál es mayor, luego, si $b$ es mayor que $c$, $b$ es el mayor.

\item Si ninguna de las anteriores condiciones se cumple, es porque el mayor era $c$. 
\end{itemize}


Lo expresado anteriormente se observa en el código \ref{cod-ifelifelse}.  \\

\lstinputlisting[language=Python,caption=El mayor de tres números,label=cod-ifelifelse]{./py/nociones/ifelifelse.py}

En cuanto a la repetición de instrucciones, se utiliza la instrucción \emph{for}, que traduce \emph{para} en español. Veamos como funciona: \\

\lstinputlisting[language=Python,caption=Repetición de instrucciones en Python,label=cod-for]{./py/nociones/for.py}

El código anterior imprime los números desde el cero hasta el nueve (como puede ver, el límite superior no se incluye). Su lectura en español nos ayudará a entenderlo: \emph{para i en el rango de 0 a 10, imprima i}. La $i$ es una variable cualquiera, por lo cuál podemos utilizar otro nombre; es común usar $i$ por su relación con los índices y subíndices en matemáticas. Los dos números dentro del paréntesis de \emph{range} indican desde que valor inicia la repetición y en cuál termina. Al igual que con la estructura \emph{if}, las instrucciones que se repiten deben ir tabuladas.

Es posible mezclar todas las instrucciones que hemos visto (y las que veremos), por ejemplo, tener programas como el del código \ref{cod-forif} que recibe dos números, imprime todos los enteros que hay entre ellos, indicando si son negativos o positivos.


\lstinputlisting[language=Python,caption=Repeticiones y decisiones en Python,label=cod-forif]{./py/nociones/forif.py}

Hasta aquí hemos visto las instrucciones básicas usaremos para controlar todos los componentes de nuestra máquina RAM. Sin embargo en los ejemplos propuesto, no se modificó demasiado la memoria del equipo. A continuación hablaremos sobre algunos mecanismos propios de la programación imperativa que permiten resolver problemas mucho más complejos.

\section{Problemas}



\newpage
